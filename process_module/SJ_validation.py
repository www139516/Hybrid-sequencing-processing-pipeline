"""
Description: This class validates the splicing junctions derived from long reads using SJ generated based on short reads using STAR.
  (FLNC CCSs).
Output: FLNC-validated sequences
Input: FLNC_corrected reads
Other notes: sj fpath generated by STAR
"""
# The codes follow is used for validation of splicing junctions.

# functions.py

import pandas as pd
from Bio.Seq import Seq
from Bio import SeqIO
import os
import subprocess
"""
    # Get the splcing junctions using gtf file obtained by long-read sequencing
   
    # 1	gmapZmV4	exon	50866	51217	99.00	-	.	transcript_id "ND-iso-new-7_5p-d_HQ_transcript/11010"; gene_id "ND-iso-new-7_5p-d_HQ_transcript/11010.gene"; gene_name "ND-iso-new-7_5p-d_HQ_transcript/11010";
    # 1	gmapZmV4	exon	51371	51436	100.00	-	.	transcript_id "ND-iso-new-7_5p-d_HQ_transcript/11010"; gene_id "ND-iso-new-7_5p-d_HQ_transcript/11010.gene"; gene_name "ND-iso-new-7_5p-d_HQ_transcript/11010";
    # 1	gmapZmV4	exon	51886	52004	100.00	-	.	transcript_id "ND-iso-new-7_5p-d_HQ_transcript/11010"; gene_id "ND-iso-new-7_5p-d_HQ_transcript/11010.gene"; gene_name "ND-iso-new-7_5p-d_HQ_transcript/11010";

    # 1	PacBio	transcript	45948	49822	.	+	.	gene_id "PB.1"; transcript_id "PB.1.1";
    # 1	PacBio	exon	45948	46148	.	+	.	gene_id "PB.1"; transcript_id "PB.1.1";
    # 1	PacBio	exon	46233	46342	.	+	.	gene_id "PB.1"; transcript_id "PB.1.1";

"""

class ValidatingSJ:
    def __init__(self):
        self._param_proj = ''
        self._o_prefix = ''
        self._collapsed_dpath = ''
        self._long_gff_fpath = ''
        self._i_short_SJ_fpath = ''
        self._i_long_seq_fpath = ''
        self._i_long_sorted_sam_fpath = ''
        self._collapsed_seq_fpath = ''
        self._o_validated_fpath = ''
        self._path_to_collapsed_py = ''
        self._sj_short_fpath = ''
        self._sj_short_loc = None
        self._sj_long_loc = None
        self._flags_seq = None

        # parameters used in collapse_isoforms_by_sam
        self._p_collapse_min_coverage = ''
        self._p_collapse_min_align_identity = ''
        self._p_collapse_fuzzy_junction = ''
        self._p_collapse_max_allow_5 = ''
        self._p_collapse_max_allow_3 = ''
        self._p_not_collapse_short5 = ''
        
        

    def fit(self, param_proj, corrected_flnc_fpath, sorted_sam_fpath, short_SJ_fpath):
        self._param_proj = param_proj
        self._o_prefix = self._param_proj.get('common_parameters', 'proj_name')
        self._collapsed_dpath = self._param_proj.get(
            'common_parameters', 'output_dir')
        if not os.path.isdir(self._collapsed_dpath):
            os.path.abspath(os.path.join(
                os.path.dirname(sorted_sam_fpath), os.path.pardir))
        self._collapsed_dpath = os.path.join(
            self._collapsed_dpath, 'collapsed')
        if not os.path.exists(self._collapsed_dpath):
            os.mkdir(self._collapsed_dpath)
        self._i_short_SJ_fpath = short_SJ_fpath
        self._i_long_seq_fpath = corrected_flnc_fpath
        self._path_to_collapsed_py = self._param_proj.get(
            'common_parameters', 'cibs_dpath')
        if os.path.isdir(self._path_to_collapsed_py):
            self._path_to_collapsed_py = os.path.join(
                self._path_to_collapsed_py, 'collapse_isoforms_by_sam.py')
        else:
            self._path_to_collapsed_py = 'collapse_isoforms_by_sam.py'
        self._i_long_sorted_sam_fpath = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'sorted_long_sam_fpath')
        if self._i_long_sorted_sam_fpath.lower() == 'auto':
            self._i_long_sorted_sam_fpath = sorted_sam_fpath
        self._i_short_SJ_fpath = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'SJ_short_fpath')
        if self._i_short_SJ_fpath.lower() == 'auto':
            self._i_short_SJ_fpath = os.path.abspath(short_SJ_fpath)
        self._long_seq_fpath = corrected_flnc_fpath
        self._o_validated_fpath = os.path.join(
            self._collapsed_dpath, self._o_prefix + '_validated.fa')
        
        # get the parameters of collapse_by_sam
        self._p_collapse_min_coverage = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'min_coverage')
        self._p_collapse_min_align_identity = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'min_align_identity')
        self._p_collapse_fuzzy_junction = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'fuzzy_junction')
        self._p_collapse_max_allow_5 = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'max_allow_5')
        self._p_collapse_max_allow_3 = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'max_allow_3')
        self._p_not_collapse_short5 = self._param_proj.get(
            'step_7_validate_SJ_and_output_seqs', 'donot_collapse_short5')
        if self._p_not_collapse_short5.lower().startswith('f'):
            self._p_not_collapse_short5 = ''
        elif self._p_not_collapse_short5.lower().startswith('t'):
            self._p_not_collapse_short5 = '--dun-merge-5-shorter'
        else:
            print("Unrecoganized parameter for collapse_isoforms_by_sam.py. Please check the config file.")
        return self

        

        

    def __collapsed_isoform(self):
        # need install bx-python 
        # conda install -c conda-forge -c bioconda bx-python
        print('Using collapse_isoforms_by_sam to process fastq file.')
        os.chdir(self._collapsed_dpath)
        cmd_claps = 'python {colaps_path} --input {corrected_flnc} -s {sorted_sam} -o {collapsed} -c {min_cov} -i {min_identity} --max_fuzzy_junction {max_fuzzy} --max_5_diff {max_5} --max_3_diff {max_3} {dun_merge_5}'.format(
            colaps_path = self._path_to_collapsed_py,
            corrected_flnc = self._i_long_seq_fpath,
            sorted_sam=self._i_long_sorted_sam_fpath,
            collapsed = '{}_colapse_seq'.format(self._o_prefix),
            min_cov = self._p_collapse_min_coverage,
            min_identity = self._p_collapse_min_align_identity,
            max_fuzzy = self._p_collapse_fuzzy_junction,
            max_5 = self._p_collapse_max_allow_5,
            max_3 = self._p_collapse_max_allow_3,
            dun_merge_5 = self._p_not_collapse_short5       
            )
        if subprocess.check_call(cmd_claps, shell=True) != 0:
            raise SystemCommandError
        self._long_gff_fpath = os.path.join(
            self._collapsed_dpath, '{}_colapse_seq.collapsed.gff'.format(self._o_prefix))
        self._collapsed_seq_fpath = os.path.join(
            self._collapsed_dpath, '{}_colapse_seq.collapsed.rep.fa'.format(self._o_prefix))
        
        
'''
    def __get_long_SJ_from_gtf(self):
        df_gtf = pd.read_csv(self._long_gff_fpath, sep='\t', names=[
                             'chr', 'genome', 'transcript_class', 'start', 'end', 'score', 'strand', 'dot', 'annotation'])
        df_gtf['id'] = df_gtf.annotation.str.split('"').apply(lambda x: x[-2])
        self._sj_long_loc = {}  # dictionary, key: isoform id, value: list containing the SJs recored in the gff generated by long-read sequencing
        sj_isoform_loc = []  # temporary vaiable, store the SJ location of the isoform

        # check every id, get the location of SJ if the id of the exon is identical to the id of the current one
    
        for i in range(len(df_gtf)-1):
            j = i + 1
            if (df_gtf.id[j] == df_gtf.id[i]) & (str(df_gtf.transcript_class[i]) == 'exon'):
                sj_start = df_gtf.end[i] + 1
                sj_end = df_gtf.start[j] - 1
                sj_isoform_loc.append(str(df_gtf.chr[i]) + '_' +
                                    str(sj_start) + '_' + str(sj_end))
            else:
                self._sj_long_loc[df_gtf.id[i]] = sj_isoform_loc
                sj_isoform_loc = []

        return self._sj_long_loc  # Returen a dict, store the location of every SJ

    def __get_short_sj_loc(self, num_cross=0):
        df_short_sj_file = pd.read_csv(self._i_short_SJ_fpath, sep='\t', names=[
            'chr', 'start', 'end', 'strand', 'in_motif', 'annotated', 'num_uni_cross', 'num_multi_cross', 'max_overhang'])
        # add a column named location, store the location of every SJ
        df_short_sj_file['num_uni_cross'].astype('int')
        fil_sj = df_short_sj_file.loc[df_short_sj_file.num_uni_cross > num_cross, :]
        fil_sj['location'] = df_short_sj_file.chr.astype(
            str) + '_' + df_short_sj_file.start.astype(str) + '_' + df_short_sj_file.end.astype(str)
        self._sj_short_loc = fil_sj.loc[:, ['location', 'num_uni_cross']]
        return self._sj_short_loc

    def __sj_validation(self):

        # check every long_reads' SJ, validate the isoform if only all SJs could be detected in the SJs obtained by short-read sequencing
        self._sj_short_loc = self.__get_short_sj_loc()
        short_sj = list(self._sj_short_loc.loc[:, 'location'])
        sj_long_loc = self.__get_long_SJ_from_gtf()
        long_sj = sj_long_loc

        # iterate every value of SJ in the long reads
        self._flags_seq = []
        for value in long_sj.values():
            # set a flag, its value is true only if all values are true, false otherwise.
            flag = True
            for i in range(len(value)):
                if value[i] not in short_sj:
                    flag = False
                    break

            self._flags_seq.append(flag)

        return self._flags_seq

    def write_the_validated_seqs(self):
        # Get the validated seqs id, and extract the sequences from sequence file
        # >PB.1.1|1:45948-49822(+)|m54286_190414_205743/55771290/ccs m54286_190414_205743/55771290/ccs
        self.__collapsed_isoform()
        print('Validating long read sequences...')
        sj_validated = self.__sj_validation()
        sj_validated = pd.DataFrame(
            {'id': list(self._sj_long_loc.keys()), 'validated': sj_validated})
        sj_after_validated = sj_validated.loc[sj_validated.validated == True, :]
        id_validated = list(sj_after_validated.id)
        print(id_validated[:10])
        with open(self._o_validated_fpath, 'w') as fa:
            for seq_record in SeqIO.parse(self._long_seq_fpath, "fasta"):
                if seq_record.id.split('|')[0] in id_validated:
                    fa.write('>{}\n'.format(seq_record.id))
                    fa.write(str(seq_record.seq) + '\n')
        return os.path.abspath(self._o_validated_fpath)
'''

        
